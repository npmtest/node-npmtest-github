{"/home/travis/build/npmtest/node-npmtest-github/test.js":"/* istanbul instrument in package npmtest_github */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-github/lib.npmtest_github.js":"/* istanbul instrument in package npmtest_github */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_github = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_github = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-github/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-github && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_github */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_github\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_github.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_github.rollup.js'] =\n            local.assetsDict['/assets.npmtest_github.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_github.__dirname +\n                    '/lib.npmtest_github.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-github/node_modules/github/lib/index.js":"\"use strict\";\n\nvar error = require(\"./error\");\nvar fs = require(\"fs\");\nvar HttpsProxyAgent = require('https-proxy-agent');\nvar mime = require(\"mime\");\nvar netrc = require(\"netrc\");\nvar Util = require(\"./util\");\nvar Url = require(\"url\");\nvar Promise = require(\"./promise\");\n\n/** section: github\n * class Client\n *\n *  Copyright 2012 Cloud9 IDE, Inc.\n *\n *  This product includes software developed by\n *  Cloud9 IDE, Inc (http://c9.io).\n *\n *  Author: Mike de Boer <mike@c9.io>\n *\n *  Upon instantiation of the [[Client]] class, the routes.json file is loaded\n *  and parsed for the API HTTP endpoints. For each HTTP endpoint to the\n *  HTTP server, a method is generated which accepts a Javascript Object\n *  with parameters and an optional callback to be invoked when the API request\n *  returns from the server or when the parameters could not be validated.\n *\n *  When an HTTP endpoint is processed and a method is generated as described\n *  above, [[Client]] also sets up parameter validation with the rules as\n *  defined in the routes.json.\n *\n *  These definitions are parsed and methods are created that the client can call\n *  to make an HTTP request to the server.\n *\n *  For example, the endpoint `gists/get-from-user` will be exposed as a member\n *  on the [[Client]] object and may be invoked with\n *\n *      client.getFromUser({\n *          \"user\": \"bob\"\n *      }, function(err, ret) {\n *          // do something with the result here.\n *      });\n *\n *      // or to fetch a specfic page:\n *      client.getFromUser({\n *          \"user\": \"bob\",\n *          \"page\": 2,\n *          \"per_page\": 100\n *      }, function(err, ret) {\n *          // do something with the result here.\n *      });\n *\n *  All the parameters as specified in the Object that is passed to the function\n *  as first argument, will be validated according to the rules in the `params`\n *  block of the route definition.\n *  Thus, in the case of the `user` parameter, according to the definition in\n *  the `params` block, it's a variable that first needs to be looked up in the\n *  `params` block of the `defines` section (at the top of the JSON file). Params\n *  that start with a `$` sign will be substituted with the param with the same\n *  name from the `defines/params` section.\n *  There we see that it is a required parameter (needs to hold a value). In other\n *  words, if the validation requirements are not met, an HTTP error is passed as\n *  first argument of the callback.\n *\n *  Implementation Notes: the `method` is NOT case sensitive, whereas `url` is.\n *  The `url` parameter also supports denoting parameters inside it as follows:\n *\n *      \"get-from-user\": {\n *          \"url\": \"/users/:owner/gists\",\n *          \"method\": \"GET\"\n *          ...\n *      }\n **/\nvar Client = module.exports = function(config) {\n    if (!(this instanceof Client)) {\n        return new Client(config);\n    }\n\n    config = config || {}\n    config.headers = config.headers || {};\n    this.config = config;\n    this.debug = Util.isTrue(config.debug);\n    this.Promise = config.Promise || config.promise || Promise;\n\n    this.routes = JSON.parse(fs.readFileSync(__dirname + \"/routes.json\", \"utf8\"));\n\n    var pathPrefix = \"\";\n    // Check if a prefix is passed in the config and strip any leading or trailing slashes from it.\n    if (typeof config.pathPrefix == \"string\") {\n        pathPrefix = \"/\" + config.pathPrefix.replace(/(^[\\/]+|[\\/]+$)/g, \"\");\n        this.config.pathPrefix = pathPrefix;\n    }\n\n    // store mapping of accept header to preview api endpoints\n    var mediaHash  = this.routes.defines.acceptTree;\n    var mediaTypes = {};\n\n    for (var accept in mediaHash) {\n        for (var route in mediaHash[accept]) {\n            mediaTypes[mediaHash[accept][route]] = accept;\n        }\n    }\n\n    this.acceptUrls = mediaTypes;\n\n    this.setupRoutes();\n};\n\n(function() {\n    /**\n     *  Client#setupRoutes() -> null\n     *\n     *  Configures the routes as defined in routes.json.\n     *\n     *  [[Client#setupRoutes]] is invoked by the constructor, takes the\n     *  contents of the JSON document that contains the definitions of all the\n     *  available API routes and iterates over them.\n     *\n     *  It first recurses through each definition block until it reaches an API\n     *  endpoint. It knows that an endpoint is found when the `url` and `param`\n     *  definitions are found as a direct member of a definition block.\n     *  Then the availability of an implementation by the API is checked; if it's\n     *  not present, this means that a portion of the API as defined in the routes.json\n     *  file is not implemented properly, thus an exception is thrown.\n     *  After this check, a method is attached to the [[Client]] instance\n     *  and becomes available for use. Inside this method, the parameter validation\n     *  and typecasting is done, according to the definition of the parameters in\n     *  the `params` block, upon invocation.\n     *\n     *  This mechanism ensures that the handlers ALWAYS receive normalized data\n     *  that is of the correct format and type. JSON parameters are parsed, Strings\n     *  are trimmed, Numbers and Floats are casted and checked for NaN after that.\n     *\n     *  Note: Query escaping for usage with SQL products is something that can be\n     *  implemented additionally by adding an additional parameter type.\n     **/\n    this.setupRoutes = function() {\n        var self = this;\n        var routes = this.routes;\n        var defines = routes.defines;\n        this.constants = defines.constants;\n        this.requestHeaders = defines[\"request-headers\"].map(function(header) {\n            return header.toLowerCase();\n        });\n        this.responseHeaders = defines[\"response-headers\"].map(function(header) {\n            return header.toLowerCase();\n        });\n        delete routes.defines;\n\n        function trim(s) {\n            if (typeof s != \"string\") {\n                return s;\n            }\n            return s.replace(/^[\\s\\t\\r\\n]+/, \"\").replace(/[\\s\\t\\r\\n]+$/, \"\");\n        }\n\n        function parseParams(msg, paramsStruct) {\n            var params = Object.keys(paramsStruct);\n            var paramName, def, value, type;\n            for (var i = 0, l = params.length; i < l; ++i) {\n                paramName = params[i];\n                if (paramName.charAt(0) == \"$\") {\n                    paramName = paramName.substr(1);\n                    if (!defines.params[paramName]) {\n                        throw new error.BadRequest(\"Invalid variable parameter name substitution; param '\" +\n                            paramName + \"' not found in defines block\", \"fatal\");\n                    } else {\n                        def = paramsStruct[paramName] = defines.params[paramName];\n                        delete paramsStruct[\"$\" + paramName];\n                    }\n                } else {\n                    def = paramsStruct[paramName];\n                }\n\n                value = msg[paramName];\n                if (typeof value != \"boolean\" && !value) {\n                    // we don't need validation for undefined parameter values\n                    // that are not required.\n                    if (!def.required ||\n                        (def[\"allow-empty\"] && value === \"\") ||\n                        (def[\"allow-null\"] && value === null)) {\n                        continue;\n                    }\n                    throw new error.BadRequest(\"Empty value for parameter '\" +\n                        paramName + \"': \" + value);\n                }\n\n                // validate the value and type of parameter:\n                if (def.validation) {\n                    if (!new RegExp(def.validation).test(value)) {\n                        throw new error.BadRequest(\"Invalid value for parameter '\" +\n                            paramName + \"': \" + value);\n                    }\n                }\n\n                if (def.type) {\n                    type = def.type.toLowerCase();\n                    if (type == \"number\") {\n                        value = parseInt(value, 10);\n                        if (isNaN(value)) {\n                            throw new error.BadRequest(\"Invalid value for parameter '\" +\n                                paramName + \"': \" + msg[paramName] + \" is NaN\");\n                        }\n                    } else if (type == \"float\") {\n                        value = parseFloat(value);\n                        if (isNaN(value)) {\n                            throw new error.BadRequest(\"Invalid value for parameter '\" +\n                                paramName + \"': \" + msg[paramName] + \" is NaN\");\n                        }\n                    } else if (type == \"json\") {\n                        if (typeof value == \"string\") {\n                            try {\n                                value = JSON.parse(value);\n                            } catch(ex) {\n                                throw new error.BadRequest(\"JSON parse error of value for parameter '\" +\n                                    paramName + \"': \" + value);\n                            }\n                        }\n                    } else if (type == \"date\") {\n                        value = new Date(value);\n                    }\n                }\n                msg[paramName] = value;\n            }\n        }\n\n        function prepareApi(struct, baseType) {\n            if (!baseType) {\n                baseType = \"\";\n            }\n            Object.keys(struct).forEach(function(routePart) {\n                var block = struct[routePart];\n                if (!block) {\n                    return;\n                }\n                var messageType = baseType + \"/\" + routePart;\n                if (block.url && block.params) {\n                    // we ended up at an API definition part!\n                    var endPoint = messageType.replace(/^[\\/]+/g, \"\");\n                    var parts = messageType.split(\"/\");\n                    var section = Util.toCamelCase(parts[1].toLowerCase());\n                    parts.splice(0, 2);\n                    var funcName = Util.toCamelCase(parts.join(\"-\"));\n\n                    if (!self[section]) {\n                        self[section] = {};\n                        // add a utility function 'getFooApi()', which returns the\n                        // section to which functions are attached.\n                        self[Util.toCamelCase(\"get-\" + section + \"-api\")] = function() {\n                            return self[section];\n                        };\n                    }\n\n                    self[section][funcName] = function(msg, callback) {\n                        try {\n                            parseParams(msg, block.params);\n                        } catch (ex) {\n                            // when the message was sent to the client, we can\n                            // reply with the error directly.\n                            self.sendError(ex, block, msg, callback);\n                            if (self.debug) {\n                                Util.log(ex.message, \"fatal\");\n                            }\n\n                            if (self.Promise && typeof callback !== 'function') {\n                                return self.Promise.reject(ex)\n                            }\n\n                            // on error, there's no need to continue.\n                            return;\n                        }\n\n                        if (!callback) {\n                            if (self.Promise) {\n                                return new self.Promise(function(resolve,reject) {\n                                    var cb = function(err, obj) {\n                                        if (err) {\n                                            reject(err);\n                                        } else {\n                                            resolve(obj);\n                                        }\n                                    };\n                                    self.handler(msg, JSON.parse(JSON.stringify(block)), cb);\n                                });\n                            } else {\n                                throw new Error('neither a callback or global promise implementation was provided');\n                            }\n                        } else {\n                            self.handler(msg, JSON.parse(JSON.stringify(block)), callback);\n                        }\n                    };\n                } else {\n                    // recurse into this block next:\n                    prepareApi(block, messageType);\n                }\n            });\n        }\n\n        prepareApi(routes);\n    };\n\n    /**\n     *  Client#authenticate(options) -> null\n     *      - options (Object): Object containing the authentication type and credentials\n     *          - type (String): One of the following: `basic`, `oauth`, `token`, or `integration`\n     *          - username (String): Github username\n     *          - password (String): Password to your account\n     *          - token (String): oauth/jwt token\n     *\n     *  Set an authentication method to have access to protected resources.\n     *\n     *  ##### Example\n     *\n     *      // basic\n     *      github.authenticate({\n     *          type: \"basic\",\n     *          username: \"mikedeboertest\",\n     *          password: \"test1324\"\n     *      });\n     *\n     *      // oauth\n     *      github.authenticate({\n     *          type: \"oauth\",\n     *          token: \"e5a4a27487c26e571892846366de023349321a73\"\n     *      });\n     *\n     *      // oauth key/secret\n     *      github.authenticate({\n     *          type: \"oauth\",\n     *          key: \"clientID\",\n     *          secret: \"clientSecret\"\n     *      });\n     *\n     *      // user token\n     *      github.authenticate({\n     *          type: \"token\",\n     *          token: \"userToken\",\n     *      });\n     *\n     *      // integration (jwt)\n     *      github.authenticate({\n     *          type: \"integration\",\n     *          token: \"jwt\",\n     *      });\n     **/\n    this.authenticate = function(options) {\n        if (!options) {\n            this.auth = false;\n            return;\n        }\n        if (!options.type || \"basic|oauth|client|token|integration|netrc\".indexOf(options.type) === -1) {\n            throw new Error(\"Invalid authentication type, must be 'basic', 'integration', 'oauth', 'client' or 'netrc'\");\n        }\n        if (options.type == \"basic\" && (!options.username || !options.password)) {\n            throw new Error(\"Basic authentication requires both a username and password to be set\");\n        }\n        if (options.type == \"oauth\") {\n            if (!options.token && !(options.key && options.secret)) {\n                throw new Error(\"OAuth2 authentication requires a token or key & secret to be set\");\n            }\n        }\n        if ((options.type == \"token\" || options.type == \"integration\") && !options.token) {\n            throw new Error(\"Token authentication requires a token to be set\");\n        }\n\n        this.auth = options;\n    };\n\n    function getPageLinks(link) {\n        if (typeof link == \"object\" && (link.link || link.meta.link)) {\n            link = link.link || link.meta.link;\n        }\n\n        var links = {};\n        if (typeof link != \"string\") {\n            return links;\n        }\n\n        // link format:\n        // '<https://api.github.com/users/aseemk/followers?page=2>; rel=\"next\", <https://api.github.com/users/aseemk/followers?page=2>; rel=\"last\"'\n        link.replace(/<([^>]*)>;\\s*rel=\"([\\w]*)\\\"/g, function(m, uri, type) {\n            links[type] = uri;\n        });\n        return links;\n    }\n\n    /**\n     *  Client#hasNextPage(link) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *\n     *  Check if a request result contains a link to the next page\n     **/\n    this.hasNextPage = function(link) {\n        return getPageLinks(link).next;\n    };\n\n    /**\n     *  Client#hasPreviousPage(link) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *\n     *  Check if a request result contains a link to the previous page\n     **/\n    this.hasPreviousPage = function(link) {\n        return getPageLinks(link).prev;\n    };\n\n    /**\n     *  Client#hasLastPage(link) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *\n     *  Check if a request result contains a link to the last page\n     **/\n    this.hasLastPage = function(link) {\n        return getPageLinks(link).last;\n    };\n\n    /**\n     *  Client#hasFirstPage(link) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *\n     *  Check if a request result contains a link to the first page\n     **/\n    this.hasFirstPage = function(link) {\n        return getPageLinks(link).first;\n    };\n\n    function getPage(link, which, headers, callback) {\n        var self = this;\n        var url = getPageLinks(link)[which];\n        if (!url) {\n            var urlErr = new error.NotFound(\"No \" + which + \" page found\");\n            return self.Promise && !callback ? self.Promise.reject(urlErr) : callback(urlErr);\n        }\n\n        var parsedUrl = Url.parse(url, true);\n\n        var msg = Object.create(parsedUrl.query);\n        if (headers != null) {\n            msg.headers = headers;\n        }\n\n        var block = {\n            url: parsedUrl.pathname,\n            method: \"GET\",\n            params: parsedUrl.query\n        };\n\n        if (!callback) {\n            if (self.Promise) {\n                return new self.Promise(function(resolve,reject) {\n                    var cb = function(err, obj) {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(obj);\n                        }\n                    };\n                    self.handler(msg, JSON.parse(JSON.stringify(block)), cb);\n                });\n            } else {\n                throw new Error('neither a callback or global promise implementation was provided');\n            }\n        } else {\n            self.handler(msg, JSON.parse(JSON.stringify(block)), callback);\n        }\n    }\n\n    /**\n     *  Client#getNextPage(link, callback) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *      - headers (Object): Optional. Key/ value pair of request headers to pass along with the HTTP request.\n     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.\n     *\n     *  Get the next page, based on the contents of the `Link` header\n     **/\n    this.getNextPage = function(link, headers, callback) {\n        if (typeof headers == 'function') {\n            callback = headers;\n            headers = null;\n        }\n        headers = applyAcceptHeader(link, headers);\n        return getPage.call(this, link, \"next\", headers, callback);\n    };\n\n    /**\n     *  Client#getPreviousPage(link, callback) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *      - headers (Object): Optional. Key/ value pair of request headers to pass along with the HTTP request.\n     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.\n     *\n     *  Get the previous page, based on the contents of the `Link` header\n     **/\n    this.getPreviousPage = function(link, headers, callback) {\n        if (typeof headers == 'function') {\n            callback = headers;\n            headers = null;\n        }\n        headers = applyAcceptHeader(link, headers);\n        return getPage.call(this, link, \"prev\", headers, callback);\n    };\n\n    /**\n     *  Client#getLastPage(link, callback) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *      - headers (Object): Optional. Key/ value pair of request headers to pass along with the HTTP request.\n     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.\n     *\n     *  Get the last page, based on the contents of the `Link` header\n     **/\n    this.getLastPage = function(link, headers, callback) {\n        if (typeof headers == 'function') {\n            callback = headers;\n            headers = null;\n        }\n        headers = applyAcceptHeader(link, headers);\n        return getPage.call(this, link, \"last\", headers, callback);\n    };\n\n    /**\n     *  Client#getFirstPage(link, callback) -> null\n     *      - link (mixed): response of a request or the contents of the Link header\n     *      - headers (Object): Optional. Key/ value pair of request headers to pass along with the HTTP request.\n     *      - callback (Function): function to call when the request is finished with an error as first argument and result data as second argument.\n     *\n     *  Get the first page, based on the contents of the `Link` header\n     **/\n    this.getFirstPage = function(link, headers, callback) {\n        if (typeof headers == 'function') {\n            callback = headers;\n            headers = null;\n        }\n        headers = applyAcceptHeader(link, headers);\n        return getPage.call(this, link, \"first\", headers, callback);\n    };\n\n    function applyAcceptHeader(res, headers) {\n        var previous = res.meta && res.meta['x-github-media-type'];\n        if (!previous || (headers && headers.accept)) {\n            return headers;\n        }\n        headers = headers || {};\n        headers.accept = 'application/vnd.' + previous.replace('; format=', '+');\n        return headers;\n    }\n\n    function getRequestFormat(hasBody, block) {\n        if (hasBody) {\n            return block.requestFormat || this.constants.requestFormat;\n        }\n        return \"query\";\n    }\n\n    function getQueryAndUrl(msg, def, format, config) {\n        var url = def.url;\n        if (config.pathPrefix && url.indexOf(config.pathPrefix) !== 0) {\n            url = config.pathPrefix + def.url;\n        }\n        var ret = {\n            query: format == \"json\" ? {} : format == \"raw\" ? msg.data : []\n        };\n        if (!def || !def.params) {\n            ret.url = url;\n            return ret;\n        }\n\n        Object.keys(def.params).forEach(function(paramName) {\n            paramName = paramName.replace(/^[$]+/, \"\");\n            if (!(paramName in msg)) {\n                return;\n            }\n\n            var isUrlParam = url.indexOf(\":\" + paramName) !== -1;\n            var valFormat = isUrlParam || format != \"json\" ? \"query\" : format;\n            var val;\n            if (valFormat != \"json\") {\n                if (typeof msg[paramName] == \"object\") {\n                    try {\n                        msg[paramName] = JSON.stringify(msg[paramName]);\n                        val = encodeURIComponent(msg[paramName]);\n                    } catch (ex) {\n                        return Util.log(\"httpSend: Error while converting object to JSON: \"\n                            + (ex.message || ex), \"error\");\n                    }\n                } else if (def.params[paramName] && def.params[paramName].combined) {\n                    // Check if this is a combined (search) string.\n                    val = msg[paramName].split(/[\\s\\t\\r\\n]*\\+[\\s\\t\\r\\n]*/)\n                                        .map(function(part) {\n                                            return encodeURIComponent(part);\n                                        })\n                                        .join(\"+\");\n                } else {\n                    // the ref param is a path so we don't want to [fully] encode it but we do want to encode the # if there is one\n                    // (see https://github.com/mikedeboer/node-github/issues/499#issuecomment-280093040)\n                    if (paramName === 'ref') {\n                        val = msg[paramName].replace(/#/g, '%23');\n                    } else {\n                        val = encodeURIComponent(msg[paramName]);\n                    }\n                }\n            } else {\n                val = msg[paramName];\n            }\n\n            if (isUrlParam) {\n                url = url.replace(\":\" + paramName, val);\n            } else {\n                if (format == \"json\" && def.params[paramName].sendValueAsBody) {\n                    ret.query = val;\n                } else if (format == \"json\") {\n                    ret.query[paramName] = val;\n                } else if (format != \"raw\") {\n                    ret.query.push(paramName + \"=\" + val);\n                }\n            }\n        });\n        ret.url = url;\n        return ret;\n    }\n\n    /**\n     *  Client#httpSend(msg, block, callback) -> null\n     *      - msg (Object): parameters to send as the request body\n     *      - block (Object): parameter definition from the `routes.json` file that\n     *          contains validation rules\n     *      - callback (Function): function to be called when the request returns.\n     *          If the the request returns with an error, the error is passed to\n     *          the callback as its first argument (NodeJS-style).\n     *\n     *  Send an HTTP request to the server and pass the result to a callback.\n     **/\n    this.httpSend = function(msg, block, callback) {\n        var self = this;\n        var method = block.method.toLowerCase();\n        var hasFileBody = block.hasFileBody;\n        var hasBody = !hasFileBody && (typeof(msg.body) !== \"undefined\" || \"head|get|delete\".indexOf(method) === -1);\n        var format = getRequestFormat.call(this, hasBody, block);\n        var protocol = this.config.protocol || this.constants.protocol || \"http\";\n        var port = this.config.port || (protocol == \"https\" ? 443 : 80);\n        var host = block.host || this.config.host || this.constants.host;\n        \n        // Edge case for github enterprise uploadAsset:\n        // 1) In public api, host changes to uploads.github.com. In enterprise, the host remains the same.\n        // 2) In enterprise, the pathPrefix changes from: /api/v3 to /api/uploads.\n        if ((this.config.host && this.config.host !== this.constants.host)\n            && (block.host && block.host === \"uploads.github.com\")) {  // enterprise uploadAsset\n            host = this.config.host;\n            this.config.pathPrefix = \"/api/uploads\";\n        }\n        \n        var obj = getQueryAndUrl(msg, block, format, self.config);\n        var query = obj.query;\n        var url = this.config.url ? this.config.url + obj.url : obj.url;\n        var path = url;\n        if (!hasBody && query.length) {\n            path += \"?\" + query.join(\"&\");\n        }\n        \n        var proxyUrl;\n        var agent = undefined;\n        if (this.config.proxy !== undefined) {\n            proxyUrl = this.config.proxy;\n        } else {\n            proxyUrl = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;\n        }\n        if (proxyUrl) {\n            agent = new HttpsProxyAgent(proxyUrl);\n        }\n        \n        var ca = this.config.ca;\n\n        var headers = {\n            \"host\": host,\n            \"content-length\": \"0\"\n        };\n        if (hasBody) {\n            if (format == \"json\") {\n                query = JSON.stringify(query);\n            } else if (format != \"raw\") {\n                query = query.join(\"&\");\n            }\n            headers[\"content-length\"] = Buffer.byteLength(query, \"utf8\");\n            headers[\"content-type\"] = format == \"json\"\n                ? \"application/json; charset=utf-8\"\n                : format == \"raw\"\n                    ? \"text/plain; charset=utf-8\"\n                    : \"application/x-www-form-urlencoded; charset=utf-8\";\n        }\n        if (this.auth) {\n            var basic;\n            switch (this.auth.type) {\n                case \"oauth\":\n                    if (this.auth.token) {\n                        path += (path.indexOf(\"?\") === -1 ? \"?\" : \"&\") +\n                            \"access_token=\" + encodeURIComponent(this.auth.token);\n                    } else {\n                        path += (path.indexOf(\"?\") === -1 ? \"?\" : \"&\") +\n                            \"client_id=\" + encodeURIComponent(this.auth.key) +\n                            \"&client_secret=\" + encodeURIComponent(this.auth.secret);\n                    }\n                    break;\n                case \"token\":\n                    headers[\"Authorization\"] = \"token \" + this.auth.token;\n                    break;\n                case \"integration\":\n                    headers[\"Authorization\"] = \"Bearer \" + this.auth.token;\n                    headers[\"accept\"] = \"application/vnd.github.machine-man-preview+json\"\n                    break;\n                case \"basic\":\n                    basic = new Buffer(this.auth.username + \":\" + this.auth.password, \"ascii\").toString(\"base64\");\n                    headers[\"Authorization\"] = \"Basic \" + basic;\n                    break;\n                case \"netrc\":\n                    var auth = netrc()[host];\n                    if (!auth) {\n                        throw new Error(\"~/.netrc authentication type chosen but no credentials found for '\" + host + \"'\");\n                    }\n                    basic = new Buffer(auth.login + \":\" + auth.password, \"ascii\").toString(\"base64\");\n                    headers[\"Authorization\"] = \"Basic \" + basic;\n                default:\n                    break;\n            }\n        }\n\n        function callCallback(err, result) {\n            if (callback) {\n                var cb = callback;\n                callback = undefined;\n                cb(err, result);\n            }\n        }\n\n        function addCustomHeaders(customHeaders) {\n            Object.keys(customHeaders).forEach(function(header) {\n                var headerLC = header.toLowerCase();\n                if (self.requestHeaders.indexOf(headerLC) == -1) {\n                    return;\n                }\n                headers[headerLC] = customHeaders[header];\n            });\n        }\n        addCustomHeaders(Util.extend(msg.headers || {}, this.config.headers));\n\n        if (!headers[\"user-agent\"]) {\n            headers[\"user-agent\"] = \"NodeJS HTTP Client\";\n        }\n\n        if (!(\"accept\" in headers)) {\n            headers[\"accept\"] = this.acceptUrls[block.url] || this.config.requestMedia || this.constants.requestMedia;\n        }\n        \n        var options = {\n            host: host,\n            port: port,\n            path: path,\n            method: method,\n            headers: headers,\n            ca: ca\n        };\n\n        if (agent) {\n            options.agent = agent;\n        }\n\n        if (this.config.rejectUnauthorized !== undefined) {\n            options.rejectUnauthorized = this.config.rejectUnauthorized;\n        }\n\n        if (this.debug) {\n            console.log(\"REQUEST: \", options);\n        }\n\n        function httpSendRequest() {\n            var reqModule = self.config.followRedirects === false ? protocol : 'follow-redirects/' + protocol;\n            var req = require(reqModule).request(options, function(res) {\n                if (self.debug) {\n                    console.log(\"STATUS: \" + res.statusCode);\n                    console.log(\"HEADERS: \" + JSON.stringify(res.headers));\n                }\n                res.setEncoding(\"utf8\");\n                var data = \"\";\n                res.on(\"data\", function(chunk) {\n                    data += chunk;\n                });\n                res.on(\"error\", function(err) {\n                    callCallback(err);\n                });\n                res.on(\"end\", function() {\n                    if (res.statusCode >= 400 && res.statusCode < 600 || res.statusCode < 10) {\n                        callCallback(new error.HttpError(data, res.statusCode, res.headers));\n                    } else {\n                        res.data = data;\n                        callCallback(null, res);\n                    }\n                });\n            });\n\n            var timeout = (block.timeout !== undefined) ? block.timeout : self.config.timeout;\n            if (timeout) {\n                req.setTimeout(timeout);\n            }\n\n            req.on(\"error\", function(e) {\n                if (self.debug) {\n                    console.log(\"problem with request: \" + e.message);\n                }\n                callCallback(e.message);\n            });\n\n            req.on(\"timeout\", function() {\n                if (self.debug) {\n                    console.log(\"problem with request: timed out\");\n                }\n                req.abort();\n                callCallback(new error.GatewayTimeout());\n            });\n\n            // write data to request body\n            if (hasBody && query.length) {\n                if (self.debug) {\n                    console.log(\"REQUEST BODY: \" + query + \"\\n\");\n                }\n                req.write(query + \"\\n\");\n            }\n\n            if (block.hasFileBody) {\n              var stream = fs.createReadStream(msg.filePath);\n              stream.pipe(req);\n            } else {\n              req.end();\n            }\n        };\n\n        if (hasFileBody) {\n            fs.stat(msg.filePath, function(err, stat) {\n                if (err) {\n                    callCallback(err);\n                } else {\n                    headers[\"content-length\"] = stat.size;\n                    headers[\"content-type\"] = mime.lookup(msg.name);\n                    httpSendRequest();\n                }\n            });\n        } else {\n            httpSendRequest();\n        }\n    };\n\n    this.sendError = function(err, block, msg, callback) {\n        if (this.debug) {\n            Util.log(err, block, msg, \"error\");\n        }\n        if (typeof err == \"string\") {\n            err = new error.InternalServerError(err);\n        }\n        if (callback && typeof(callback) === \"function\") {\n            callback(err);\n        }\n    };\n\n    this.handler = function(msg, block, callback) {\n        var self = this;\n        this.httpSend(msg, block, function(err, res) {\n            if (err) {\n                return self.sendError(err, msg, null, callback);\n            }\n\n            var ret;\n            try {\n                var data = res.data;\n                \n                var contentType = res.headers[\"content-type\"];\n                if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n                    data = res.data && JSON.parse(res.data);\n                }\n                ret = {data: data};\n            } catch (ex) {\n                if (callback) {\n                    callback(new error.InternalServerError(ex.message), res);\n                }\n                return;\n            }\n\n            if (!ret) {\n                ret = {};\n            }\n            ret.meta = {};\n            self.responseHeaders.forEach(function(header) {\n                if (res.headers[header]) {\n                    ret.meta[header] = res.headers[header];\n                }\n            });\n\n            if (callback) {\n                callback(null, ret);\n            }\n        });\n    }\n}).call(Client.prototype);\n","/home/travis/build/npmtest/node-npmtest-github/node_modules/github/lib/error.js":"/** section: github\n * class HttpError\n *\n *  Copyright 2012 Cloud9 IDE, Inc.\n *\n *  This product includes software developed by\n *  Cloud9 IDE, Inc (http://c9.io).\n *\n *  Author: Mike de Boer <mike@c9.io>\n **/\n\nvar Util = require(\"util\");\n\nexports.HttpError = function(message, code, headers) {\n    Error.call(this, message);\n    //Error.captureStackTrace(this, arguments.callee);\n    this.message = message;\n    this.code = code;\n    this.status = statusCodes[code];\n    this.headers = headers;\n};\nUtil.inherits(exports.HttpError, Error);\n\n(function() {\n    /**\n     *  HttpError#toString() -> String\n     *\n     *  Returns the stringified version of the error (i.e. the message).\n     **/\n    this.toString = function() {\n        return this.message;\n    };\n\n    /**\n     *  HttpError#toJSON() -> Object\n     *\n     *  Returns a JSON object representation of the error.\n     **/\n    this.toJSON = function() {\n        return {\n            code: this.code,\n            status: this.status,\n            message: this.message\n        };\n    };\n\n}).call(exports.HttpError.prototype);\n\n\nvar statusCodes = {\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    405: \"Method Not Allowed\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authentication Required\",\n    408: \"Request Timeout\",\n    409: \"Conflict\",\n    410: \"Gone\",\n    411: \"Length Required\",\n    412: \"Precondition Failed\",\n    413: \"Request Entity Too Large\",\n    414: \"Request-URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Requested Range Not Satisfiable\",\n    417: \"Expectation Failed\",\n    420: \"Enhance Your Calm\",\n    422: \"Unprocessable Entity\",\n    423: \"Locked\",\n    424: \"Failed Dependency\",\n    425: \"Unordered Collection\",\n    426: \"Upgrade Required\",\n    428: \"Precondition Required\",\n    429: \"Too Many Requests\",\n    431: \"Request Header Fields Too Large\",\n    444: \"No Response\",\n    449: \"Retry With\",\n    499: \"Client Closed Request\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Gateway Timeout\",\n    505: \"HTTP Version Not Supported\",\n    506: \"Variant Also Negotiates\",\n    507: \"Insufficient Storage\",\n    508: \"Loop Detected\",\n    509: \"Bandwidth Limit Exceeded\",\n    510: \"Not Extended\",\n    511: \"Network Authentication Required\"\n};\n\n// XXX: Remove?\nfor (var status in statusCodes) {\n    var defaultMsg = statusCodes[status];\n\n    var error = (function(defaultMsg, status) {\n        return function(msg) {\n            this.defaultMessage = defaultMsg;\n            exports.HttpError.call(this, msg || status + \": \" + defaultMsg, status);\n\n            if (status >= 500)\n                Error.captureStackTrace(this, arguments.callee);\n        };\n    })(defaultMsg, status);\n\n    Util.inherits(error, exports.HttpError);\n\n    var className = toCamelCase(defaultMsg);\n    exports[className] = error;\n    exports[status] = error;\n}\n\nfunction toCamelCase(str) {\n    return str.toLowerCase().replace(/(?:(^.)|(\\s+.))/g, function(match) {\n        return match.charAt(match.length-1).toUpperCase();\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-github/node_modules/github/lib/util.js":"/** section: github\n * class Util\n *\n *  Copyright 2012 Cloud9 IDE, Inc.\n *\n *  This product includes software developed by\n *  Cloud9 IDE, Inc (http://c9.io).\n *\n *  Author: Mike de Boer <mike@c9.io>\n **/\n\nvar Util = require(\"util\");\n\n/**\n *  Util#extend(dest, src, noOverwrite) -> Object\n *      - dest (Object): destination object\n *      - src (Object): source object\n *      - noOverwrite (Boolean): set to `true` to overwrite values in `src`\n *\n *  Shallow copy of properties from the `src` object to the `dest` object. If the\n *  `noOverwrite` argument is set to to `true`, the value of a property in `src`\n *  will not be overwritten if it already exists.\n **/\nexports.extend = function(dest, src, noOverwrite) {\n    for (var prop in src) {\n        if (!noOverwrite || typeof dest[prop] == \"undefined\") {\n            dest[prop] = src[prop];\n        }\n    }\n    return dest;\n};\n\n/**\n *  Util#escapeRegExp(str) -> String\n *      - str (String): string to escape\n *\n *  Escapes characters inside a string that will an error when it is used as part\n *  of a regex upon instantiation like in `new RegExp(\"[0-9\" + str + \"]\")`\n **/\nexports.escapeRegExp = function(str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n};\n\n/**\n *  Util#toCamelCase(str, [upper]) -> String\n *      - str (String): string to transform\n *      - upper (Boolean): set to `true` to transform to CamelCase\n *\n *  Transform a string that contains spaces or dashes to camelCase. If `upper` is\n *  set to `true`, the string will be transformed to CamelCase.\n *\n *  Example:\n *\n *      Util.toCamelCase(\"why U no-work\"); // returns 'whyUNoWork'\n *      Util.toCamelCase(\"I U no-work\", true); // returns 'WhyUNoWork'\n **/\nexports.toCamelCase = function(str, upper) {\n    str = str.toLowerCase().replace(/(?:(^.)|(\\s+.)|(-.))/g, function(match) {\n        return match.charAt(match.length - 1).toUpperCase();\n    });\n    if (upper) {\n        return str;\n    }\n    return str.charAt(0).toLowerCase() + str.substr(1);\n};\n\n/**\n *  Util#isTrue(c) -> Boolean\n *      - c (mixed): value the variable to check. Possible values:\n *          true   The function returns true.\n *          'true' The function returns true.\n *          'on'   The function returns true.\n *          1      The function returns true.\n *          '1'    The function returns true.\n *\n *  Determines whether a string is true in the html attribute sense.\n **/\nexports.isTrue = function(c){\n    return (c === true || c === \"true\" || c === \"on\" || typeof c == \"number\" && c > 0 || c === \"1\");\n};\n\n/**\n *  Util#isFalse(c) -> Boolean\n *      - c (mixed): value the variable to check. Possible values:\n *          false   The function returns true.\n *          'false' The function returns true.\n *          'off'   The function returns true.\n *          0       The function returns true.\n *          '0'     The function returns true.\n *\n *  Determines whether a string is false in the html attribute sense.\n **/\nexports.isFalse = function(c){\n    return (c === false || c === \"false\" || c === \"off\" || c === 0 || c === \"0\");\n};\n\nvar levels = {\n    \"info\":  [\"\\u001b[90m\", \"\\u001b[39m\"], // grey\n    \"error\": [\"\\u001b[31m\", \"\\u001b[39m\"], // red\n    \"fatal\": [\"\\u001b[35m\", \"\\u001b[39m\"], // magenta\n    \"exit\":  [\"\\u001b[36m\", \"\\u001b[39m\"]  // cyan\n};\nvar _slice = Array.prototype.slice;\n\n/**\n *  Util#log(arg1, [arg2], [type]) -> null\n *      - arg1 (mixed): messages to be printed to the standard output\n *      - type (String): type denotation of the message. Possible values:\n *          'info', 'error', 'fatal', 'exit'. Optional, defaults to 'info'.\n *\n *  Unified logging to the console; arguments passed to this function will put logged\n *  to the standard output of the current process and properly formatted.\n *  Any non-String object will be inspected by the NodeJS util#inspect utility\n *  function.\n *  Messages will be prefixed with its type (with corresponding font color), like so:\n *\n *      [info] informational message\n *      [error] error message\n *      [fatal] fatal error message\n *      [exit] program exit message (not an error)\n *\n * The type of message can be defined by passing it to this function as the last/\n * final argument. If the type can not be found, this last/ final argument will be\n * regarded as yet another message.\n **/\nexports.log = function() {\n    var args = _slice.call(arguments);\n    var lastArg = args[args.length - 1];\n\n    var level = levels[lastArg] ? args.pop() : \"info\";\n    if (!args.length) {\n        return;\n    }\n\n    var msg = args.map(function(arg) {\n        return typeof arg != \"string\" ? Util.inspect(arg) : arg;\n    }).join(\" \");\n    var pfx = levels[level][0] + \"[\" + level + \"]\" + levels[level][1];\n\n    msg.split(\"\\n\").forEach(function(line) {\n        console.log(pfx + \" \" + line);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-github/node_modules/github/lib/promise.js":"\"use strict\";\n\nvar Promise = global.Promise || null;\n\nif (isFunction(Promise)) {\n    new Promise(function(resolver) {\n        if (!isFunction(resolver)) {\n            Promise = null;\n        }\n    });\n}\n\nmodule.exports = Promise;\n\nfunction isFunction(x) {\n    return typeof x === \"function\";\n}\n"}